export = Transaction;
/**
 * @typedef {import('./rpc/types/formatter').CallRequest} TransactionMeta
 */
declare class Transaction {
    /**
     * Decode rlp encoded raw transaction hex string
     *
     * @param {string} raw - rlp encoded transaction hex string
     * @returns {Transaction} A Transaction instance
     */
    static decodeRaw(raw: string): Transaction;
    /**
     * Create a transaction.
     *
     * @param {object} options
     * @param {string} [options.from] - The sender address.
     * @param {string|number} [options.nonce] - This allows to overwrite your own pending transactions that use the same nonce.
     * @param {string|number} [options.gasPrice] - The price of gas for this transaction in drip.
     * @param {string|number} [options.gas]- The amount of gas to use for the transaction (unused gas is refunded).
     * @param {string} [options.to] - The destination address of the message, left undefined for a contract-creation transaction.
     * @param {string|number} [options.value] - The value transferred for the transaction in drip, also the endowment if itâ€™s a contract-creation transaction.
     * @param {string|number} [options.storageLimit] - The storage limit specified by the sender.
     * @param {string|number} [options.epochHeight] - The epoch proposed by the sender. Note that this is NOT the epoch of the block containing this transaction.
     * @param {string|number} [options.chainId] - The chain ID specified by the sender.
     * @param {string|Buffer} [options.data]- Either a ABI byte string containing the data of the function call on a contract, or in the case of a contract-creation transaction the initialisation code.
     * @param {string|Buffer} [options.r] - ECDSA signature r
     * @param {string|Buffer} [options.s] - ECDSA signature s
     * @param {number} [options.v] - ECDSA recovery id
     * @return {Transaction}
     */
    constructor({ from, nonce, gasPrice, gas, to, value, storageLimit, epochHeight, chainId, data, v, r, s }: {
        from?: string;
        nonce?: string | number;
        gasPrice?: string | number;
        gas?: string | number;
        to?: string;
        value?: string | number;
        storageLimit?: string | number;
        epochHeight?: string | number;
        chainId?: string | number;
        data?: string | Buffer;
        r?: string | Buffer;
        s?: string | Buffer;
        v?: number;
    });
    from: string;
    nonce: string | number;
    gasPrice: string | number;
    gas: string | number;
    to: string;
    value: string | number;
    storageLimit: string | number;
    epochHeight: string | number;
    chainId: string | number;
    data: string | Buffer;
    v: number;
    r: string | Buffer;
    s: string | Buffer;
    /**
     * Getter of transaction hash include signature.
     *
     * > Note: calculate every time.
     *
     * @return {string|undefined} If transaction has r,s,v return hex string, else return undefined.
     */
    get hash(): string;
    /**
     * Sign transaction and set 'r','s','v'.
     *
     * @param {string} privateKey - Private key hex string.
     * @param {number} networkId - fullnode's network id.
     * @return {Transaction}
     */
    sign(privateKey: string, networkId: number): Transaction;
    /**
     * Recover public key from signed Transaction.
     *
     * @return {string}
     */
    recover(): string;
    /**
     * Encode rlp.
     *
     * @param {boolean} [includeSignature=false] - Whether or not to include the signature.
     * @return {Buffer}
     */
    encode(includeSignature?: boolean): Buffer;
    /**
     * Get the raw transaction hex string.
     *
     * @return {string} Hex string
     */
    serialize(): string;
}
declare namespace Transaction {
    export { TransactionMeta };
}
type TransactionMeta = import('./rpc/types/formatter').CallRequest;
//# sourceMappingURL=Transaction.d.ts.map