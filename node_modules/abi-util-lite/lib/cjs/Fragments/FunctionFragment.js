"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.FunctionFragment = void 0;
var Logger_1 = require("../Logger");
var ParamType_1 = require("../ParamType");
var Fragments_1 = require("./Fragments");
var ConstructorFragment_1 = require("./ConstructorFragment");
var Checkers_1 = require("../Checkers");
var Utils_1 = require("../Utils");
var Format_1 = require("../Format");
var FunctionFragment = /** @class */ (function (_super) {
    __extends(FunctionFragment, _super);
    function FunctionFragment() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    FunctionFragment.from = function (value) {
        if (typeof (value) === "string") {
            return FunctionFragment.fromString(value);
        }
        return FunctionFragment.fromObject(value);
    };
    FunctionFragment.prototype.format = function (format) {
        if (!format) {
            format = Format_1.FormatTypes.sighash;
        }
        if (!Format_1.FormatTypes[format]) {
            Logger_1.logger.throwArgumentError("invalid format type", "format", format);
        }
        if (format === Format_1.FormatTypes.json) {
            return JSON.stringify({
                type: "function",
                name: this.name,
                constant: this.constant,
                stateMutability: this.stateMutability,
                payable: this.payable,
                // gas: (this.gas ? this.gas.toNumber(): undefined),
                inputs: this.inputs.map(function (input) { return JSON.parse(input.format(format)); }),
                outputs: this.outputs.map(function (output) { return JSON.parse(output.format(format)); }),
            });
        }
        var result = "";
        if (format !== Format_1.FormatTypes.sighash) {
            result += "function ";
        }
        result += this.name + "(" + this.inputs.map(function (input) { return input.format(format); }).join((format === Format_1.FormatTypes.full) ? ", " : ",") + ") ";
        if (format !== Format_1.FormatTypes.sighash) {
            if (this.stateMutability) {
                if (this.stateMutability !== "nonpayable") {
                    result += (this.stateMutability + " ");
                }
            }
            else if (this.constant) {
                result += "view ";
            }
            if (this.outputs && this.outputs.length) {
                result += "returns (" + this.outputs.map(function (output) { return output.format(format); }).join(", ") + ") ";
            }
            // if (this.gas != null) {
            //     result += "@" + this.gas.toString() + " ";
            // }
        }
        return result.trim();
    };
    FunctionFragment.fromObject = function (value) {
        if (FunctionFragment.isFunctionFragment(value)) {
            return value;
        }
        if (value.type !== "function") {
            Logger_1.logger.throwArgumentError("invalid function object", "value", value);
        }
        var state = (0, Checkers_1.verifyState)(value);
        var params = {
            type: value.type,
            name: (0, Checkers_1.verifyIdentifier)(value.name),
            constant: state.constant,
            inputs: (value.inputs ? value.inputs.map(ParamType_1.ParamType.fromObject) : []),
            outputs: (value.outputs ? value.outputs.map(ParamType_1.ParamType.fromObject) : []),
            payable: state.payable,
            stateMutability: state.stateMutability,
        };
        return new FunctionFragment(Utils_1._constructorGuard, params);
    };
    FunctionFragment.fromString = function (value) {
        var params = { type: "function" };
        var comps = value.split(" returns ");
        if (comps.length > 2) {
            Logger_1.logger.throwArgumentError("invalid function string", "value", value);
        }
        var parens = comps[0].match(Fragments_1.regexParen);
        if (!parens) {
            Logger_1.logger.throwArgumentError("invalid function signature", "value", value);
        }
        params.name = parens[1].trim();
        if (params.name) {
            (0, Checkers_1.verifyIdentifier)(params.name);
        }
        params.inputs = (0, ParamType_1.parseParams)(parens[2], false);
        (0, Fragments_1.parseModifiers)(parens[3].trim(), params);
        // We have outputs
        if (comps.length > 1) {
            var returns = comps[1].match(Fragments_1.regexParen);
            if (returns[1].trim() != "" || returns[3].trim() != "") {
                Logger_1.logger.throwArgumentError("unexpected tokens", "value", value);
            }
            params.outputs = (0, ParamType_1.parseParams)(returns[2], false);
        }
        else {
            params.outputs = [];
        }
        return FunctionFragment.fromObject(params);
    };
    FunctionFragment.isFunctionFragment = function (value) {
        return (value && value._isFragment && value.type === "function");
    };
    return FunctionFragment;
}(ConstructorFragment_1.ConstructorFragment));
exports.FunctionFragment = FunctionFragment;
//# sourceMappingURL=FunctionFragment.js.map