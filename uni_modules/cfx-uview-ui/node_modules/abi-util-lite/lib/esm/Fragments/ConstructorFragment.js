"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConstructorFragment = void 0;
var Logger_1 = require("../Logger");
var ParamType_1 = require("../ParamType");
var Fragments_1 = require("./Fragments");
var Checkers_1 = require("../Checkers");
var Utils_1 = require("../Utils");
var Format_1 = require("../Format");
var ConstructorFragment = /** @class */ (function (_super) {
    __extends(ConstructorFragment, _super);
    function ConstructorFragment() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // gas?: BigNumber;
    ConstructorFragment.prototype.format = function (format) {
        if (!format) {
            format = Format_1.FormatTypes.sighash;
        }
        if (!Format_1.FormatTypes[format]) {
            Logger_1.logger.throwArgumentError("invalid format type", "format", format);
        }
        if (format === Format_1.FormatTypes.json) {
            return JSON.stringify({
                type: "constructor",
                stateMutability: this.stateMutability,
                // payable: this.payable,
                inputs: this.inputs.map(function (input) { return JSON.parse(input.format(format)); })
            });
        }
        if (format === Format_1.FormatTypes.sighash) {
            Logger_1.logger.throwError("cannot format a constructor for sighash", Logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "format(sighash)"
            });
        }
        var result = "constructor(" + this.inputs.map(function (input) { return input.format(format); }).join((format === Format_1.FormatTypes.full) ? ", " : ",") + ") ";
        if (this.stateMutability && this.stateMutability !== "nonpayable") {
            result += this.stateMutability + " ";
        }
        return result.trim();
    };
    ConstructorFragment.from = function (value) {
        if (typeof (value) === "string") {
            return ConstructorFragment.fromString(value);
        }
        return ConstructorFragment.fromObject(value);
    };
    ConstructorFragment.fromObject = function (value) {
        if (ConstructorFragment.isConstructorFragment(value)) {
            return value;
        }
        if (value.type !== "constructor") {
            Logger_1.logger.throwArgumentError("invalid constructor object", "value", value);
        }
        var state = (0, Checkers_1.verifyState)(value);
        if (state.constant) {
            Logger_1.logger.throwArgumentError("constructor cannot be constant", "value", value);
        }
        var params = {
            name: null,
            type: value.type,
            inputs: (value.inputs ? value.inputs.map(ParamType_1.ParamType.fromObject) : []),
            payable: state.payable,
            stateMutability: state.stateMutability,
            // gas: (value.gas ? BigNumber.from(value.gas): null)
        };
        return new ConstructorFragment(Utils_1._constructorGuard, params);
    };
    ConstructorFragment.fromString = function (value) {
        var params = { type: "constructor" };
        // value = parseGas(value, params);
        var parens = value.match(Fragments_1.regexParen);
        if (!parens || parens[1].trim() !== "constructor") {
            Logger_1.logger.throwArgumentError("invalid constructor string", "value", value);
        }
        params.inputs = (0, ParamType_1.parseParams)(parens[2].trim(), false);
        (0, Fragments_1.parseModifiers)(parens[3].trim(), params);
        return ConstructorFragment.fromObject(params);
    };
    ConstructorFragment.isConstructorFragment = function (value) {
        return (value && value._isFragment && value.type === "constructor");
    };
    return ConstructorFragment;
}(Fragments_1.Fragment));
exports.ConstructorFragment = ConstructorFragment;
//# sourceMappingURL=ConstructorFragment.js.map