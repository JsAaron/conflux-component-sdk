"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractABI = exports.parseABIFromString = void 0;
var Format_1 = require("./Format");
var Fragments_1 = require("./Fragments");
var Logger_1 = require("./Logger");
var Utils_1 = require("./Utils");
/**
 *
 * @param fragments string representation of contract abi, could either be array or string
 * @returns
 */
function parseABIFromString(fragments) {
    var c = new ContractABI(fragments);
    return JSON.parse(c.format("json"));
}
exports.parseABIFromString = parseABIFromString;
var ContractABI = /** @class */ (function () {
    function ContractABI(fragments) {
        var _newTarget = this.constructor;
        var _this = this;
        Logger_1.logger.checkNew(_newTarget, ContractABI);
        var abi = [];
        if (typeof (fragments) === "string") {
            abi = JSON.parse(fragments);
        }
        else {
            abi = fragments;
        }
        (0, Utils_1.defineReadOnly)(this, "fragments", abi.map(function (fragment) {
            return (0, Fragments_1.parseFragment)(fragment);
        }).filter(function (fragment) { return (fragment != null); }));
        (0, Utils_1.defineReadOnly)(this, "functions", {});
        (0, Utils_1.defineReadOnly)(this, "errors", {});
        (0, Utils_1.defineReadOnly)(this, "events", {});
        (0, Utils_1.defineReadOnly)(this, "structs", {});
        // Add all fragments by their signature
        this.fragments.forEach(function (fragment) {
            var bucket = null;
            switch (fragment.type) {
                case "constructor":
                    // if (this.deploy) {
                    //   logger.warn("duplicate definition - constructor");
                    //   return;
                    // }
                    //checkNames(fragment, "input", fragment.inputs);
                    // defineReadOnly(this, "deploy", <ConstructorFragment>fragment);
                    return;
                case "function":
                    //checkNames(fragment, "input", fragment.inputs);
                    //checkNames(fragment, "output", (<FunctionFragment>fragment).outputs);
                    bucket = _this.functions;
                    break;
                case "event":
                    //checkNames(fragment, "input", fragment.inputs);
                    bucket = _this.events;
                    break;
                case "error":
                    bucket = _this.errors;
                    break;
                default:
                    return;
            }
            var signature = fragment.format();
            if (bucket[signature]) {
                Logger_1.logger.warn("duplicate definition - " + signature);
                return;
            }
            bucket[signature] = fragment;
        });
        // If we do not have a constructor add a default
        // if (!this.deploy) {
        //   defineReadOnly(this, "deploy", ConstructorFragment.from({
        //     payable: false,
        //     type: "constructor"
        //   }));
        // }
        // defineReadOnly(this, "_isInterface", true);
    }
    ContractABI.prototype.format = function (format) {
        if (!format) {
            format = Format_1.FormatTypes.full;
        }
        if (format === Format_1.FormatTypes.sighash) {
            Logger_1.logger.throwArgumentError("interface does not support formatting sighash", "format", format);
        }
        var abi = this.fragments.map(function (fragment) { return fragment.format(format); });
        // We need to re-bundle the JSON fragments a bit
        if (format === Format_1.FormatTypes.json) {
            return JSON.stringify(abi.map(function (j) { return JSON.parse(j); }));
        }
        return abi;
    };
    return ContractABI;
}());
exports.ContractABI = ContractABI;
//# sourceMappingURL=ContractABI.js.map