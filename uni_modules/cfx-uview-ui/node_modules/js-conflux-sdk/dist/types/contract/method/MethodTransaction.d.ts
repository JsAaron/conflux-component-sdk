export = MethodTransaction;
/**
 * @typedef { import('../../Transaction').TransactionMeta } TransactionMeta
 */
declare class MethodTransaction extends Transaction {
    constructor(options: any, method: any);
    /**
     * Will send a transaction to the smart contract and execute its method.
     * set contract.address as `to`,
     * set contract method encode as `data`.
     *
     * > Note: This can alter the smart contract state.
     *
     * @param {TransactionMeta} options - See [Transaction](Transaction.md#Transaction.js/Transaction/**constructor**)
     * @param {string} [password] - See [conflux.sendTransaction](#Conflux.js/Conflux/sendTransaction)
     * @return {import('../../subscribe/PendingTransaction')} The PendingTransaction object.
     */
    sendTransaction(options: TransactionMeta, ...extra: any[]): import('../../subscribe/PendingTransaction');
    populateTransaction(options: any): any;
    /**
     * Executes a message call or transaction and returns the amount of the gas used.
     * set contract.address as `to`,
     * set contract method encode as `data`.
     *
     * @param {TransactionMeta} options - See [Transaction](Transaction.md#Transaction.js/Transaction/**constructor**)
     * @param {string|number} epochNumber - See [Conflux.estimateGasAndCollateral](#Conflux.js/estimateGasAndCollateral)
     * @return {Promise<import('../../rpc/types/formatter').EstimateResult>} The gas used and storage occupied for the simulated call/transaction.
     */
    estimateGasAndCollateral(options: TransactionMeta, epochNumber: string | number): Promise<import('../../rpc/types/formatter').EstimateResult>;
    /**
     * Executes a message call transaction,
     * set contract.address as `to`,
     * set contract method encode as `data`.
     *
     * > Note: Can not alter the smart contract state.
     *
     * @param {TransactionMeta} options - See [Transaction](Transaction.md#Transaction.js/Transaction/**constructor**)
     * @param {string|number} epochNumber - See [Conflux.call](#Conflux.js/call)
     * @return {Promise<*>} Decoded contact call return.
     */
    call(options: TransactionMeta, epochNumber: string | number): Promise<any>;
    request(options: any, epochNumber: any): any;
    then(resolve: any, reject: any): Promise<any>;
    catch(callback: any): Promise<any>;
    finally(callback: any): Promise<any>;
}
declare namespace MethodTransaction {
    export { TransactionMeta };
}
import Transaction = require("../../Transaction");
type TransactionMeta = import('../../Transaction').TransactionMeta;
//# sourceMappingURL=MethodTransaction.d.ts.map